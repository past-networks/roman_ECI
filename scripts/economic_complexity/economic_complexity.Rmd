---
title: "economic_complexity"
author: "Matteo Mazzamurro"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
This R markdown allows to reproduce the preliminary steps to study the economic complexity of the Roman empire.
The input data are the (Latin) inscriptions containing occupational information.
The output are tables of occupation counts per geographic unit, before and after the correction of uncertainty and biases.

# Structure
The document is structured as follows:
* Preliminaries: 
  Loading the necessary packages and data.
* Defining consistent occupational units by standardizing the spelling. 
* Defining different geographical units: modern countries, Roman provinces, cities.
* Create the tables of occupational counts per geographical units.
* Deal with the uncertainty and biases in the datasets.

# Preliminaries
## Packages
The following libraries are required.
```{r List required packages}
required_packages <- c("jsonlite",     # read json files
                       "arrow",        # read parquet files
                       "tidyverse",    # data cleaning and visualisation
                       "stringi",      # handle strings for spelling standardisation
                       "sf",           # load and handle spatial files
                       "raster",       # handle spatial files
                       "units",        # add physical units for geographic comparison
                       "ggspatial",    # additional plot features for spatial data
                       "triangulr")    # triangular distribution 
```

One needs to install them if they have not been installed yet.
```{r Install missing packages}
packages_to_install <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(packages_to_install)) install.packages(packages_to_install)
```

Finally, one needs to load them.
```{r Load required packages}
invisible(lapply(required_packages, library, character.only = TRUE))
```

Note that we use the following versions of the packages:
* jsonlite    : 1.8.7
* arrow       : 15.0.1
* tidyverse   : 2.0.0
* stringi     : 1.7.12
* sf          : 1.0.15
* raster      : 3.6.26
* units       : 0.8.2
* ggspatial   : 1.1.9
* triangulr   : 1.2.1

These were loaded in the R version 4.3.0.

To check your version of an installed package and R, you may use the following commands.
```{r check R and package version}
# R version
R.version

# example package version
packageVersion("tidyverse")
```

If a package has been updated since the release of this code, using the newer version may cause issues.

If the installed version is causing issues, one can try to solve them by installing the specific versions of the packages by uncommenting and running the following code. 
Note, however, that these older versions of the packages may not be available for newer versions of R, in which case it will be necessary to switch to an older version of R to run the code (please refer to the cran.r website on how to do that: https://cran.r-project.org/index.html).

```{r}
# #install devtools if not already installed
# if (!"devtools" %in% installed.packages()[,"Package"]) install.packages("devtools")
# 
# #load devtools
# library(devtools)
# 
# #install specific versions of the packages
# install_version("jsonlite", version = "1.8.7")
# install_version("arrow", version = "15.0.1")
# install_version("tidyverse", version = "2.0.0")
# install_version("stringi", version = "1.7.12")
# install_version("sf", version = "1.0.15")
# install_version("raster", version = "3.6.26")
# install_version("units", version = "0.8.2")
# install_version("ggspatial", version = "1.1.9")
# install_version("triangulr", version = "1.2.1")
# 
# #load packages
# invisible(lapply(required_packages, library, character.only = TRUE))
```

## Data TO MODIFY WITH CORRECT PATHS
CREATE A NEW DIRECTORY
DOWNLOAD FILES IN IT TO DO

Read the data on inscriptions and standardised spelling
```{r read data on inscriptions}
# inscriptions
inscriptions <- read_parquet("../../data/economic_complexity/LIST_occupsorgs_industry_simple_20231206.parquet")

# occupations to merge 
occupations_all <- read_delim("../../data/economic_complexity/occupations.csv", delim=";")
occupations_to_merge <- read_delim("../../data/economic_complexity/occupations_to_merge.csv", delim=";")

# inscriptions containing people
EDH_people <- read_csv("C:/Users/au732923/OneDrive - Aarhus Universitet/Desktop/PSNP/EDH_sna/data/EDH_people_2021.csv")

# epitaphs
epitaphs <- inscriptions[inscriptions$type_of_inscription_auto %in% c("epitaph"),]
```


Read the data on geographical units. THESE ARE LOCAL PATHS. NEED INSTRUCTION ON HOW TO DOWNLOAD
```{r geographical data}
# cities based on Hanson's dataset
cities <- st_read("../../data/economic_complexity/roman_cities_pop.geojson")

# Roman provinces (digitised and corrected by Adam Pažout)
## read the data
provinces <- read_sf("../../data/economic_complexity/roman_provinces_cleaned/roman_provinces_foranalysisdissolved.shp")
## transform it in a relevant coordinate reference system
provinces <- st_transform(provinces, crs=crs("epsg:4326"))
## delete Roma since it lies inside Latium
provinces <- provinces[!provinces$province=="Roma",]
## delete unnecessary columns for our scopes
provinces <- provinces[,c("province","geometry")]

# country borders
## read the data from local path. Need to download from https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/world-administrative-boundaries/exports/shp 
world_sf <- read_sf('../../data/economic_complexity/world-administrative-boundaries/world-administrative-boundaries.shp') 
## dissolve the administrative boundaries for visualisation purposes
world_no_borders_sf <- st_union(world_sf) 
```

# Occupational units
First, select only the inscriptions containing information on occupations
```{r select inscriptions with occupations}
inscriptions_w_occupations <- inscriptions[inscriptions$occups_N>0,]
```

ATTEMPT: CREATE STANDARD SPELLING DF
```{r TO CHECK}
occupations_to_merge_min <- occupations_to_merge[,c("Main_term","To_be_merged")]

occupations_to_merge_separated <- occupations_to_merge_min %>%
  separate_rows(To_be_merged, sep = ", ") %>%
  mutate(To_be_merged = trimws(To_be_merged)) # Remove leading/trailing spaces if any

# Rename columns if needed
colnames(occupations_to_merge_separated) <- c("standard_spelling", "alternative_spellings")

```


Add a standard spelling column to the occupations.
```{r standardise occupation spelling TO CHECK}
# ensure no unwanted space are there in the terms
occupations_all$Term <- trim(occupations_all$Term)

# find full names of occupations by attaching Term2 if present
occupations_all$Term_full <- ifelse(!is.na(occupations_all$Term2),
                                    paste(occupations_all$Term,occupations_all$Term2),
                                    occupations_all$Term)
                                           
#initialise column of standard spelling 
occupations_all$std_spelling <- NA

for (i in seq(nrow(occupations_all))) {
  occ_term <- occupations_all$Term_full[i]
  # for an occupational term, see if it needs to be merged 
  #occ_word_match <- str_detect(occupations_to_merge$To_be_merged,occ_term)

 # in case it does, merge it, otherwise, the term itself is the standard spelling
  #occupations_all$std_spelling[i] <- ifelse(any(occ_word_match),
  #       occupations_to_merge$Main_term[occ_word_match],
  #       occ_term)
  
  
   # MISTAKE HERE: NEED TO match this
  occupations_all$std_spelling[i] <- ifelse(occ_term %in% occupations_to_merge_separated$alternative_spellings,
                                            occupations_to_merge_separated$standard_spelling[which(occupations_to_merge_separated$alternative_spellings==occ_term)],
                                            occ_term
                                            )
}

# select only necessary columns
occupations_dictionary <- unique(occupations_all[,c("Term_full","std_spelling")]) %>%
  setNames(c("Term","std_spelling"))

# initialise new column of standard spelling for occupations in inscriptions
inscriptions_w_occupations$occups_std <- rep(list(NA),nrow(inscriptions_w_occupations))

for (i in seq(nrow(inscriptions_w_occupations))){
  # extract an inscription
  inscription <- inscriptions_w_occupations[i,]
  # find the occupations in the inscription and associate it with the standard spellings
  inscription_occ <- data.frame(Term=unlist(inscription$occups)) %>%
    left_join(occupations_dictionary,
              by = "Term")
  # save the standard spellings for the occupations in the inscription
  inscriptions_w_occupations$occups_std[[i]] <- inscription_occ$std_spelling
}
```

Extract info on unique occupations in inscriptions to fil the table
```{r unique occupations for online table TO DO}
unique_occupations_in_inscriptions_df <- data.frame(std_spelling = sort(unique(unlist(inscriptions_w_occupations$occups_std)))) %>% 
  left_join(occupations_all,by=join_by(std_spelling),)

#write.csv(unique_occupations_in_inscriptions_df,"../../results/economic_complexity/unique_occupations_in_inscriptions.csv")

```

# Geographical units
Note that naive methods (e.g., using a cell raster) do not work, as each geographical unit must have at least one inscription and the data is very sparse.

As a first step, convert the inscriptions into a sf
```{r create sf of inscriptions}
# occupations with inscriptions
inscriptions_w_occupations_sf <- st_as_sf(inscriptions_w_occupations,
                                          coords = c("Longitude","Latitude"),
                                          crs = crs("epsg:4326"))

# epitaphs
epitaphs_sf <- st_as_sf(epitaphs,
                        coords = c("Longitude","Latitude"),
                        crs = crs("epsg:4326"))
```

## Modern countries
### Inscriptions with occupations
First associate the inscriptions with occupations to the corresponding (closest) country
```{r inscriptions in countries}
inscriptions_coordinates <- data.frame(st_coordinates(inscriptions_w_occupations_sf)) %>% 
  setNames(c("Longitude","Latitude"))

inscriptions_in_countries <- cbind(inscriptions_w_occupations_sf,
                                   country = world_sf$iso3[st_nearest_feature(inscriptions_w_occupations_sf,world_sf)],
                                   inscriptions_coordinates)
```

Visual check: represent the inscriptions as points on a map and colour them according to the province they are assigned to
```{r visualise distribution of inscriptions by country}
# base map
inscriptions_by_country_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_countries,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_coordinates$Longitude), 
                    max(inscriptions_coordinates$Longitude)), 
           ylim = c(min(inscriptions_coordinates$Latitude), 
                    max(inscriptions_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_country_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_country.pdf", inscriptions_by_country_plot, width = 7, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_country.jpeg", inscriptions_by_country_plot, width = 7, height = 5.5, dpi = 300)
```

One inscription lies in Norway, which is very suspicious. Create another file without it
```{r delete inscription in Norway and plot}
inscriptions_in_countries_no_Norway <- inscriptions_in_countries[!inscriptions_in_countries$country=="NOR",]

# base map
inscriptions_by_country_no_Norway_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_countries_no_Norway,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_in_countries_no_Norway$Longitude), 
                    max(inscriptions_in_countries_no_Norway$Longitude)), 
           ylim = c(min(inscriptions_in_countries_no_Norway$Latitude), 
                    max(inscriptions_in_countries_no_Norway$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_country_no_Norway_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_country_no_Norway.pdf", inscriptions_by_country_no_Norway_plot, width = 10, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_country_no_Norway.jpeg", inscriptions_by_country_no_Norway_plot, width = 10, height = 5.5, dpi = 300)
```

### Epitaphs
We do the same for the epitaphs.
```{r epitaphs in countries}
epitaphs_coordinates <- data.frame(st_coordinates(epitaphs_sf)) %>% 
  setNames(c("Longitude","Latitude"))

epitaphs_in_countries <- cbind(epitaphs_sf,
                                   country = world_sf$iso3[st_nearest_feature(epitaphs_sf,world_sf)],
                                   epitaphs_coordinates)
```
Visual check 
```{r map epitaphs by country}
# base map
epitaphs_by_country_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = epitaphs_in_countries,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(epitaphs_coordinates$Longitude), 
                    max(epitaphs_coordinates$Longitude)), 
           ylim = c(min(epitaphs_coordinates$Latitude), 
                    max(epitaphs_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(epitaphs_by_country_plot)
#ggsave("../../figures/economic_complexity/epitaphs_by_country.pdf", epitaphs_by_country_plot, width = 7, height = 5.5)
#ggsave("../../figures/economic_complexity/epitaphs_by_country.jpeg", epitaphs_by_country_plot, width = 7, height = 5.5, dpi = 300)
```

## Roman provinces
### Inscriptions with occupations
Repeat the same process using as geographical units the Roman provinces at Trajan's time.
Note that province borders were constantly shifting, so this choice is in principle not more meaningful than using modern country borders.

Associate each inscription to the province in which it falls
```{r inscriptions in provinces}
inscriptions_in_provinces <- st_join(inscriptions_w_occupations_sf, provinces)
inscriptions_in_provinces$Latitude <- inscriptions_w_occupations$Latitude
inscriptions_in_provinces$Longitude <- inscriptions_w_occupations$Longitude
```

Notice that 72 inscriptions lie outside of the borders of the provinces.
```{r inscriptions without a province}
unassigned_inscriptions_index <- which(is.na(inscriptions_in_provinces$province))
unassigned_inscriptions <- inscriptions_w_occupations[unassigned_inscriptions_index,]
unassigned_inscriptions_sf <- st_as_sf(unassigned_inscriptions,
                                       coords = c("Longitude","Latitude"),
                                       crs = crs("epsg:4326"))
```

Quick plot of the points to see their distribution
```{r plot inscriptions without a province}
# base map
plot(provinces$geometry, 
     xlim = c(min(inscriptions_w_occupations$Longitude),
              max(inscriptions_w_occupations$Longitude)),
     ylim = c(min(inscriptions_w_occupations$Latitude),
              max(inscriptions_w_occupations$Latitude)))
# show in red the points not associated with any province
points(unassigned_inscriptions$Longitude,
       unassigned_inscriptions$Latitude,
       col="red")
```

For some of these, this is simply a problem of the precision of the shapefile.
This is the case of inscriptions near the coast or northern border, or for inscriptions on the Balearic islands (which are not part of the shapefile of provinces)
For others, they lie outside of our area of interest and it is not possible to assign them a priori to a province on the basis of this shapefile only.
One needs to deal with these on a case by case scenario, considering the limitations of the data and of the shapefile.

Find the closest province to each unassigned inscription and compute the distance
```{r closest province to each unassigned inscription}
# province index
closest_province_index <- st_nearest_feature(unassigned_inscriptions_sf,provinces)
# assign name of the closest province 
unassigned_inscriptions$closest_province <- provinces$province[closest_province_index]
# compute distance to the closest province
unassigned_inscriptions$distance_to_province <- st_distance(
  unassigned_inscriptions_sf,
  provinces[closest_province_index,],
  by_element = TRUE)
```

Automatically assign a point to a province if the distance is smaller than 50km.
This is a relatively arbitrary threshold, corresponding to the minimal threshold that allows to deal with most of the aforementioned cases of clear lack of assignment while leaving out ambiguous or clearly wrong ones as determined by visual inspection.
```{r assign very close inscriptions to closest province}
inscriptions_in_provinces$province[unassigned_inscriptions_index] <- ifelse(
  unassigned_inscriptions$distance_to_province < set_units(50000,"meters"),
  unassigned_inscriptions$closest_province,
  NA
)
```

Manually assign the case of the Balearic islands
```{r assign Balearic inscriptions to Hispania Citerior}
Balearic_inscriptions_id <- unassigned_inscriptions[unassigned_inscriptions$closest_province=="Hispania Citerior","LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% Balearic_inscriptions_id$`LIST-ID`] <- "Hispania Citerior"
```

Unclear cases beyond the border are manually classified as either "Eastern border" or "North-eastern border", with the exception of the isolated case in Norway, that is dropped. This is debatable, but should have limited impact on the analysis
```{r categorise/clean outlier inscriptions}
# Eastern border
Eastern_inscriptions <- unassigned_inscriptions[unassigned_inscriptions$Longitude > 40,"LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% Eastern_inscriptions$`LIST-ID`] <- "Eastern border"

# update unassigned inscriptions
remaining_unassigned_inscriptions <- inscriptions_w_occupations[which(is.na(inscriptions_in_provinces$province)),]

# North Eastern border
North_easter_inscriptions <- remaining_unassigned_inscriptions[remaining_unassigned_inscriptions$Latitude < 60,"LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% North_easter_inscriptions$`LIST-ID`] <- "North-eastern border"

# delete outlier
inscriptions_in_provinces <- inscriptions_in_provinces[!is.na(inscriptions_in_provinces$province),]
```

Visual check: represent the inscriptions as points on a map and colour them according to the province they are assigned to.
```{r visualise distribution of inscriptions by province}
# base map
inscriptions_by_province_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_provinces,
             aes(color = province)) +
  #geom_point(data = inscriptions_in_provinces,
  #           aes(x = Longitude,
  #               y = Latitude,
  #               color = province)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_in_provinces$Longitude), 
                    max(inscriptions_in_provinces$Longitude)), 
           ylim = c(min(inscriptions_in_provinces$Latitude), 
                    max(inscriptions_in_provinces$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_province_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_province.pdf", inscriptions_by_province_plot, width = 15, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_province.jpeg", inscriptions_by_province_plot, width = 15, height = 5.5, dpi = 300)
```

### Epitaphs
The same process is repeated for the epitaphs
```{r}
epitaphs_in_provinces <- st_join(epitaphs_sf, provinces)
# remark: 15 inscriptions fall at the borders between two provinces. For the time being, we assign them at random (may look for the impact of this uncertainty later, but it's likely very small as the counts are large)
epitaphs_in_provinces <- epitaphs_in_provinces[which(!duplicated(epitaphs_in_provinces$`LIST-ID`)),]

epitaphs_in_provinces$Latitude <- epitaphs$Latitude
epitaphs_in_provinces$Longitude <- epitaphs$Longitude
```

Notice that 1657 inscriptions lie outside of the borders of the provinces.
```{r epitaphs without a province}
unassigned_epitaphs_index <- which(is.na(epitaphs_in_provinces$province))
unassigned_epitaphs <- epitaphs[unassigned_epitaphs_index,]
unassigned_epitaphs_sf <- st_as_sf(unassigned_epitaphs,
                                   coords = c("Longitude","Latitude"),
                                   crs = crs("epsg:4326"))
```

We deal with these exactly as above.
```{r find closest province to unassigned epitaphs}
# province index
closest_province_epitaphs_index <- st_nearest_feature(unassigned_epitaphs_sf,provinces)
# assign name of the closest province 
unassigned_epitaphs$closest_province <- provinces$province[closest_province_epitaphs_index]
# compute distance to the closest province (see if the loop is necessary. I put it because otherwise the memory was suffering)
unassigned_epitaphs$distance_to_province <- NA
for (i in 1:nrow(unassigned_epitaphs)) {
  unassigned_epitaphs$distance_to_province[i] <- st_distance(
  unassigned_epitaphs_sf[i,],
  provinces[closest_province_epitaphs_index[i],],
  by_element = TRUE)
  if (!i%%50) print(i) 
}
unassigned_epitaphs$distance_to_province <- set_units(unassigned_epitaphs$distance_to_province,"meters")
```

```{r assign epitaphs to closest province if very close}
epitaphs_in_provinces$province[unassigned_epitaphs_index] <- ifelse(
  unassigned_epitaphs$distance_to_province < set_units(50000,"meters"),
  unassigned_epitaphs$closest_province,
  NA
)
```

```{r manually assign epitaphs in Balearic, Achaia, Sicilia, and Britannia}
# Balearic
Balearic_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Hispania Citerior","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Balearic_epitaphs_id$`LIST-ID`] <- "Hispania Citerior"

# Achaia
Achaia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Achaia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Achaia_epitaphs_id$`LIST-ID`] <- "Achaia"

# Sicila
Sicilia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Sicilia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Sicilia_epitaphs_id$`LIST-ID`] <- "Sicilia"

# Britannia
Britannia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Britannia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Britannia_epitaphs_id$`LIST-ID`] <- "Britannia"
```

THIS CLASSIFICATION  MAY BE DONE MORE CAREFULLY

```{r classify other borders epitaphs}
# Eastern border
Eastern_epitaphs <- unassigned_epitaphs[unassigned_epitaphs$Longitude > 40,"LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Eastern_epitaphs$`LIST-ID`] <- "Eastern border"

# update unassigned inscriptions
remaining_unassigned_epitaphs <- epitaphs[which(is.na(epitaphs_in_provinces$province)),]

# North Eastern border
North_easter_epitaphs <- remaining_unassigned_epitaphs[remaining_unassigned_epitaphs$Latitude < 50 & remaining_unassigned_epitaphs$Latitude > 42,"LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% North_easter_epitaphs$`LIST-ID`] <- "North-eastern border"

# Desert outliers to delete
epitaphs_in_provinces <- epitaphs_in_provinces[!is.na(epitaphs_in_provinces$province),]
```

```{r visual check of epitaphs in provinces}
# base map
epitaphs_by_province_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = epitaphs_in_provinces,
             aes(color = province)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(epitaphs_in_provinces$Longitude), 
                    max(epitaphs_in_provinces$Longitude)), 
           ylim = c(min(epitaphs_in_provinces$Latitude), 
                    max(epitaphs_in_provinces$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(epitaphs_by_province_plot)
#ggsave("../../figures/economic_complexity/epitaphs_by_province.pdf", epitaphs_by_province_plot, width = 15, height = 5.5)
#ggsave("../../figures/economic_complexity/epitaphs_by_province.jpeg", epitaphs_by_province_plot, width = 15, height = 5.5, dpi = 300)
```


## Urban inscriptions
Associate each inscription to the closest town in the Pleiades data set
```{r find and associate each inscription to the closest town}
# find closest city
nearest_city_index = st_nearest_feature(inscriptions_w_occupations_sf, cities)

# initialise inscription to closest city sf
inscriptions_in_cities <- cbind(inscriptions_w_occupations_sf,
                                nearest_city_key = cities$Primary.Key[nearest_city_index],
                                nearest_city_ancient_toponym = cities$Ancient.Toponym[nearest_city_index],
                                nearest_city_modern_toponym = cities$Modern.Toponym[nearest_city_index],
                                nearest_city_pop_est = cities$pop_est[nearest_city_index],
                                nearest_city_area = cities$Area[nearest_city_index],
                                inscriptions_coordinates)

# associate the distance
inscriptions_in_cities$distance_to_city <- st_distance(
  inscriptions_in_cities,
  cities[nearest_city_index,],
  by_element = TRUE)
```

Assign an inscription to a city if the distance is below a certain threshold.
First consider the case when the threshold is an arbitrary distance from the city (from very small to max 1h walk) 
```{r assign cities if within a certain arbitrary threshold}
# arbitrary threshold
thresholds <- c(500,1000,2000,5000) #max 1h walking from the centre

# initialise columns
inscriptions_in_cities <- cbind(inscriptions_in_cities,
                                data.frame(matrix(NA,ncol=4)) %>% 
                                  setNames(
                                    paste0("city_",thresholds)
                                    )
                                )

# assign cities only if within a certain threshold
for (t in thresholds){
  inscriptions_in_cities[paste0("city_",t)] <- ifelse(
    inscriptions_in_cities$distance_to_city < set_units(t,"meters"),
    inscriptions_in_cities$nearest_city_key,
    "rural"
  )
}
```

The consider slighly more sophisticated or area-dependent threshold: i.e., a threshold that corresponds to an estimate of the city's radius based on its area.
The area is expressed in hectars in Hanson's database. 
1 hectare is 10000 square meters (i.e., a square 100mx100m).
First, convert the hectar into square meters
Then compute the radius of a circle of a given area using the inverse formula of the area r = sqrt(A/pi).

Remark that when the area is NA, the population is assigned an arbitrary value of 1000. 
For cities with a population of 1000 whose area is indicated, the area is between 1 and 10 hectares, with a mean of approx 6.9 (and similar median of 7). 
Here, the mean value is taken as the radius. 
A sensitivity analysis should follow.

```{r assign city if within an area-dependent threshold}
# average radius for cities with 1000 people
mean_area_1000people <- mean(na.omit(cities$Area[cities$pop_est==1000]))

# define appropriate threshold for each city 
area_based_threshold <- ifelse(
  !is.na(inscriptions_in_cities$nearest_city_area),
  sqrt(inscriptions_in_cities$nearest_city_area*10000/pi),
  sqrt(mean_area_1000people*10000/pi)
)

# assign cities based on area-based threshold
inscriptions_in_cities$city_area_based <- ifelse(
  inscriptions_in_cities$distance_to_city < set_units(area_based_threshold,"meters"),
  inscriptions_in_cities$nearest_city_key,
  "rural"
)
```
 
Hence, one has a classification of the urban occupation-related inscriptions. 
Note that this is a subset of all the occupation-related inscriptions.
```{r county urban inscriptions}
print(
  paste0("Total count of urban inscriptions by threshold. ",
        "Area-adapted threshold: ",
        length(inscriptions_in_cities$city_area_based[!inscriptions_in_cities$city_area_based=="rural"]),
        ", 500m: ",
        length(inscriptions_in_cities$city_500[inscriptions_in_cities$city_500=="rural"]),
        ", 1000m: ",
        length(na.omit(inscriptions_in_cities$city_1000[inscriptions_in_cities$city_1000=="rural"])),
        ", 2000m: ",
        length(na.omit(inscriptions_in_cities$city_2000[inscriptions_in_cities$city_2000=="rural"])),
        ", 5000m: ",
        length(na.omit(inscriptions_in_cities$city_5000[inscriptions_in_cities$city_5000=="rural"]))
  )
)
```

# Table of occupations
Now, build the table of occupations per geographic unit depending on the choice of the latter.
## Country
Prepare the data in the correct format by unlisting the occupations in each inscription
```{r unnest the df}
# unnest the df based on the standard names
inscriptions_in_countries_no_Norway_unnested <- unnest(inscriptions_in_countries_no_Norway,"occups_std")
```

Define the row and column names, in this case the countries and the occupations respectively.
```{r country table construction: row and column names}
# col names (occupations, sorted by frequency)
col_names_c <- names(
  sort(
    table(
      inscriptions_in_countries_no_Norway_unnested$occups_std),
    decreasing=TRUE)
  )

# row names (countries, sorted by total counts)
row_names_c <- names(
  sort(
    table(
      inscriptions_in_countries_no_Norway_unnested$country),
    decreasing=TRUE)
  )
```

Then, define the table of frequencies of occupations by country.
```{r country table definition}
# initialisation
country_table <- table(inscriptions_in_countries_no_Norway_unnested$country,
                        inscriptions_in_countries_no_Norway_unnested$occups_std)

# sort based on row and column counts
country_table <- country_table[row_names_c,col_names_c]
```

Represent the table as a heatmap. Note that due to the extreme concentration of inscriptions and occupations in some provinces, here the log of the frequency is shown.
```{r country heatmap}
# Convert the table to a dataframe
country_table_heatmap <- as.data.frame(country_table) %>% setNames(c("country","occupation","frequency"))
country_table_heatmap$log_frequency <- log(country_table_heatmap$frequency)

country_table_heatmap_plot <- ggplot(country_table_heatmap, aes(occupation, country, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "country", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by country") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))
```

Finally, save the results.
```{r save results}
write.csv(country_table,"../../results/economic_complexity/country_table.csv")
ggsave("../../figures/economic_complexity/country_table_heatmap.pdf", country_table_heatmap_plot, width = 15, height = 10)
ggsave("../../figures/economic_complexity/country_table_heatmap.jpeg", country_table_heatmap_plot, width = 15, height = 10, dpi = 300)
```


## Province
Repeat the same process as above for provinces. 
Start by unlisting the occupation data for each inscription
```{r unnest the df}
# unnest the df based on the standard names
inscriptions_in_provinces_unnested <- unnest(inscriptions_in_provinces,"occups_std")
```

Define the row and column names, in this case the provinces and the occupations respectively.
```{r country table construction: row and column names}
# col names (occupations, sorted by frequency)
col_names_p <- names(
  sort(
    table(
      inscriptions_in_provinces_unnested$occups_std),
    decreasing=TRUE)
  )

# row names (countries, sorted by total counts)
row_names_p <- names(
  sort(
    table(
      inscriptions_in_provinces_unnested$province),
    decreasing=TRUE)
  )
```

Define the frequency table of occupations by province.
```{r country table definition}
# initialisation
province_table <- table(inscriptions_in_provinces_unnested$province,
                        inscriptions_in_provinces_unnested$occups_std)

# sort based on row and column counts
province_table <- province_table[row_names_p,col_names_p]
```

Represent the table as a heatmap. Note that due to the extreme concentration of inscriptions and occupations in some provinces, here the log of the frequency is shown.
```{r province heatmap}
province_table_heatmap <- as.data.frame(province_table) %>% setNames(c("province","occupation","frequency"))
province_table_heatmap$log_frequency <- log(province_table_heatmap$frequency)

province_table_heatmap_plot <- ggplot(province_table_heatmap, aes(occupation, province, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "province", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by province") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))

print(province_table_heatmap_plot)
```

Finally, save the results
```{r save results}
write.csv(province_table,"../../results/economic_complexity/province_table.csv")
ggsave("../../figures/economic_complexity/province_table_heatmap.pdf", province_table_heatmap_plot, width = 15, height = 10)
ggsave("../../figures/economic_complexity/province_table_heatmap.jpeg", province_table_heatmap_plot, width = 15, height = 10, dpi = 300)
```

## Cities
For the cities, one needs to deal with the different radii used in assigning an inscription to a city. Use a function for conciseness.
```{r function to plot occupation structure based on threshold}
cities_table_heapmap_by_threshold <- function(t){
  if (!t %in% c(thresholds,"area_based")){
    stop("The threshold value must '500', '1000', '2000', '5000' or 'area_based'",
         call. = F)
  }
  
  # select column depending on threshold choice
  city_col <- paste0("city_",t)
  # exclude rural inscriptions
  inscriptions_in_cities_no_rural <- inscriptions_in_cities[!inscriptions_in_cities[[city_col]]=="rural",]
  # unnest the list
  inscriptions_in_cities_unnested <- unnest(inscriptions_in_cities_no_rural,"occups_std")

  # col names (occupations, sorted by frequency)
  col_names_c <- names(
  sort(
    table(
      inscriptions_in_cities_unnested$occups_std),
    decreasing=TRUE)
  )

  # row names (countries, sorted by total counts)
  row_names_c <- names(
  sort(
    table(
      inscriptions_in_cities_unnested[[city_col]]),
    decreasing=TRUE)
  )
  
  # define table
  # initialisation
  cities_table <- table(inscriptions_in_cities_unnested[[city_col]],
                        inscriptions_in_cities_unnested$occups_std)

  # sort based on row and column counts
  cities_table <- cities_table[row_names_c,col_names_c]
  
  # heatmap
  cities_table_heatmap <- as.data.frame(cities_table) %>% setNames(c("city_ID","occupation","frequency"))
  cities_table_heatmap$log_frequency <- log(cities_table_heatmap$frequency)
  cities_table_heatmap <- left_join(cities_table_heatmap,
                                    cities[,c("Primary.Key","Ancient.Toponym")],
                                    by = join_by(city_ID==Primary.Key)) %>%
    setNames(c("city_ID","occupation","frequency","log_frequency","ancient_toponym","geometry")) 
    
  cities_table_heatmap$city_ID <- factor(cities_table_heatmap$city_ID, 
                                 row_names_c)
  cities_table_heatmap$occupation <- factor(cities_table_heatmap$occupation, 
                                 col_names_c)
  
  heatmap_plot <- ggplot(cities_table_heatmap, aes(occupation, city_ID, fill=log_frequency)) + 
    geom_tile() +
    scale_fill_gradient(low = "white", high = "red") +
    labs(x = "occupation", 
         y = "city ID", 
         fill ="log(frequency)",
         title = paste0("Frequency of occupations in inscriptions by city. Threshold: ",t)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2),
          axis.text.y = element_text(size = 2))
  
  # save results
  write.csv(cities_table,paste0("../../results/economic_complexity/cities_table_threshold_",t,".csv"))
  ggsave(paste0("../../figures/economic_complexity/heatmap_cities_",t,".pdf"), heatmap_plot, width = 15, height = 10)
  ggsave(paste0("../../figures/economic_complexity/heatmap_cities_",t,".jpeg"), heatmap_plot, width = 15, height = 10, dpi = 300)
  
  # visualise them
  print(heatmap_plot)
  return(cities_table)
}
```

Run the function to output and save the results.
```{r run the above function}
cities_table_list <- list()
for (t in c(thresholds,"area_based")) {
  cities_table_t <- cities_table_heapmap_by_threshold(t)
  cities_table_list <- append(cities_table_list,
                              cities_table_t)
}
```

# Uncertainty and biases TO DO

The above tables were constructed by using the occupation data as it was directly extracted from the inscriptions. 

However, inscriptions do not represent a realistic view of the real occupational structure. Sources of bias include:
* Gender bias: inscriptions in general contain information about men than women. 
* Research bias: uneven research interest in different occupations and geographical areas, imperfect detection method, etc. 
* Occupation bias: some occupations are systematically underreported (e.g., farmers)
* Language bias: the dataset includes only latin inscriptions, but a large number of inscriptions were written in Greek, especially in the Eastern side of the Roman empire. 

In this section we propose to systematically address these biases with the aim to reach more accurate estimates of the real distribution of occupations.

## Functions to address bias TO DO
We do this by constructing functions to each source of bias.

### Gender TO DO ¨
We multiply women-only occupations (which for simplicity we take to be those with female-only names), by a corrective factor, derived from the men/women ratio in funerary inscriptions. 

```{r extract info about gender inscriptions}
# compute a table of frequency of gender from funerary inscriptions
EDH_epitaphs <- EDH_people[EDH_people$type_of_inscription_clean=="epitaph",]
EDH_gender <- table(EDH_epitaphs$gender)
EDH_gender_NA <- sum(is.na(EDH_epitaphs$gender))
print(EDH_gender)
print(paste("NA values:", EDH_gender_NA))

# select female occupations
occupations_female <- occupations_all$std_spelling[occupations_all$gender=="female"]
```

Gender is specified as "female", "male", but also uncertain but probably male "M?", uncertain but probably female "W?", and undefined (NA). We account for this in the definition of the ratio.
```{r compute the men/women ratio in funerary inscriptions}
gender_ratio_simple <- as.numeric(EDH_gender["male"]/EDH_gender["female"])
gender_ratio_max <- (EDH_gender[["male"]]+EDH_gender[["M?"]]+EDH_gender[["W?"]]+EDH_gender_NA)/EDH_gender[["female"]]
gender_ratio_min <- EDH_gender[["male"]]/(EDH_gender[["female"]]+EDH_gender[["M?"]]+EDH_gender[["W?"]]+EDH_gender_NA)
```

Randomly generate bias correction values based on a triangular distribution with range (gender_ratio_min,gender_ratio_max) and peak at gender_ratio_simple.

```{r vector of gender ratio bias}
# randomly generate the vector according to a triangular distribution
gender_ratio_v <- rtri(n = 1000,
                       min = gender_ratio_min,
                       max = gender_ratio_max,
                       mode = gender_ratio_simple)

# visual check of the distribution of the results
plot(hist(gender_ratio_v,20))
```

```{r gender bias function}
gender_bias <- function(table, bias){
  # update columns with female occupations
  table[,colnames(table)%in%occupations_female] <- bias*table[,colnames(table)%in%occupations_female] 
  return(table)
}
```


### Research TO DO
To establish which geographical areas are overrepresented in inscriptions, we can use the ratio between funerary inscriptions and population, the assumption being that deaths happen (theoretically) proportionally to the population.

To do this, we need to estimate the total population residing in each geographical unit.  

#### Population by geographical unit
As far as we know, there are no estimates of the Ancient Roman population at the provincial level (and certainly not within the borders of modern nations or town hinterlands).

Instead, a set of estimates exist for the total population in 10 macroregions of the Empire (Table 3.1 in "Scheidel W. Demography. In: Scheidel W, Morris I, Saller RP, eds. The Cambridge Economic History of the Greco-Roman World. Cambridge University Press; 2007:38-86") and for the population of individual urban units (Hanson).

For each macroregion, we compute the urban population by summing the population estimates of all the urban areas falling within it.
We subtract the urban population to obtain an estimate of the rural population in the macroregion. 

To each province in the macroregion, we find the urban population by summing the population estimates of the urban areas falling within it. We find the rural population by taking a part of the rural population of the macroregion, proportionate to the area of the province.

Note that this is the same as assuming that the rural population density is approximately constant within a macroregion. This is a crude assumption, but the most natural one that can be made with limited data and without additional population models. In the future, it can be improved by integrating additional information (e.g., terrain and suitability to agriculture).

##### Provinces
First, associate each province to the macroregion mentioned by Scheidel.
```{r assign each province to its macroregion}
provinces_macroregions_list <- list(
  Italy_and_islands = c(
    "Aemilia (Regio VIII)",
    "Apulia et Calabria (Regio II)",
    "Bruttium et Lucania (Regio III)",
    "Corsica",
    "Etruria (Regio VII)",
    "Latium et Campania (Regio I)",
    "Liguria (Regio IX)",
    "Picenum (Regio V)",
    "Samnium (Regio IV)",
    "Sardinia",
    "Sicilia",
    "Transpadana (Regio XI)",
    "Umbria (Regio VI)",
    "Venetia et Histria (Regio X)"
  ),
  Iberia = c(
    "Baetica",
    "Hispania Citerior",
    "Lusitania"
    ),
  Gaul_and_Germany = c(
    "Alpes Cottiae",
    "Alpes Graiae",
    "Alpes Maritimae",
    "Alpes Poeninae",
    "Aquitania",
    "Belgica",
    "Germania Inferior",
    "Germania Superior",
    "Lugdunensis",
    "Narbonensis",
    "Raetia"
    ),
  Britain = c(
    "Britannia"
    ),
  Danubian_region = c(
    "Dacia",
    "Dalmatia",
    "Moesia Inferior",
    "Moesia Superior",
    "Noricum",
    "Pannonia Inferior",
    "Pannonia Superior"
    ),
  Greek_peninsula = c(
    "Achaia",
    "Creta",
    "Epirus",
    "Macedonia",
    "Thracia"
    ),
  Anatolia = c(
    "Asia",
    "Bithynia et Pontus",
    "Cappadocia",
    "Cilicia",
    "Lycia et Pamphylia",
    "Galatia"
    ),
  Greater_Syria = c(
    "Arabia",
    "Cyprus",
    "Iudaea",
    "Syria"
    ),
  Egypt = c(
    "Aegyptus"
    ),
  North_Africa = c(
    "Africa Proconsularis",
    "Cyrene",
    "Mauretania Caesariensis",
    "Mauretania Tingitana",
    "Numidia")
)

# transform to dataframe
provinces_macroregions_df<-data.frame(unlist(provinces_macroregions_list)) %>% setNames("province")
provinces_macroregions_df$macroregion <- provinces_macroregions_df %>% rownames() %>% str_remove_all("[0-9]") %>% str_replace_all("_"," ")
rownames(provinces_macroregions_df) <- NULL
```

Compute the area of each province, and the area of each macroregion
```{r areas of provinces and macroregions}
# areas of the provinces
provinces_areas_df <- data.frame(province = provinces$province,
                                 area = st_area(provinces))

provinces_macroregions_areas_df <- left_join(provinces_macroregions_df,
                                       provinces_areas_df)

# areas of the macroregions
macroregions_areas_df <- provinces_macroregions_areas_df %>%
  group_by(macroregion) %>%
  summarize(macroregion_area = sum(area))
```

Find the proportion of the area of each macroregion falling in a specific province
```{r province area/macroregion area}
# add to the province and macroregions df the areas of the macroregions
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_areas_df,
  macroregions_areas_df,
  by = join_by(macroregion))

# find the proportion of the macroregion's area falling in each province
provinces_macroregions_full_info_df$area_proportion <- as.numeric(
  provinces_macroregions_full_info_df$area/provinces_macroregions_full_info_df$macroregion_area)
```

Create an sf object of the macroregions DOES NOT WORK
```{r macroregions sf SKIP}
# associate macroregions to provinces in the sf
#provinces_macroregions <- left_join(provinces,
#                                    provinces_macroregions_df)

# unite macroregions
#macroregions <- provinces_macroregions %>%
#  group_by(macroregion) %>%
#  summarize() %>%
#  st_union()

#st_write(macroregions,"C:/Users/au732923/OneDrive - Aarhus Universitet/Desktop/macroregions.shp")
```

Compute the urban population for each province.
```{r urban population by province}
# assign each city to its closest province 
# RK: the province may differ from those used by Hanson, and we need this step to ensure consistency.
closest_province_to_city_index <- st_nearest_feature(cities,provinces)
cities_in_provinces_df <- data.frame(
  Primary.Key = cities$Primary.Key,
  Ancient.Toponym = cities$Ancient.Toponym,
  pop_est = cities$pop_est,
  province = provinces$province[closest_province_to_city_index]
  )

# compute the urban population by province
province_urban_population_df <- cities_in_provinces_df %>%
  group_by(province) %>%
  summarize(urban_pop = sum(pop_est)) 
```

If there are provinces without cities, assign population 0.
This is actualy the case of the Alpes Graiae. 
```{r provinces without cities}
# add a row with value 0 
province_urban_population_df <- rbind(
  province_urban_population_df,
  data.frame(
    province = provinces$province[
      which(!provinces$province %in%
              province_urban_population_df$province)],
    urban_pop = 0
    )
)

# sort alphabetically
province_urban_population_df <- province_urban_population_df[order(province_urban_population_df$province),]
```

Finally coompute the urban population by macroregion.
```{r urban population by macroregion}
# urban population of the macroregions
macroregions_urban_population_df <- province_urban_population_df %>%
  left_join(provinces_macroregions_areas_df) %>%
  group_by(macroregion) %>%
  summarize(urban_pop = sum(urban_pop))

#RK: HANSON'S CITY POPULATION DATA SHOULD CONTAIN MORE INFO ON THE INHERENT UNCERTAINTY
```

Then digitise the total population estimates for each macroregion.
```{r manually encode population estimates for the macroregions}
# Data based on "Scheidel W. Demography. In: Scheidel W, Morris I, Saller RP, eds. The Cambridge Economic History of the Greco-Roman World. Cambridge University Press; 2007:38-86." Table 3.1
macroregion_pop_165AD_df <- data.frame(
  macroregion = c("Italy and islands", 
                  "Iberia", 
                  "Gaul and Germany",
                  "Britain",
                  "Danubian region",
                  "Greek peninsula",
                  "Anatolia",
                  "Greater Syria",
                  "Egypt",
                  "North Africa"),
  tot_pop_min = c(12000000,
                  7000000,
                  9000000,
                  1500000,
                  5000000,
                  2500000,
                  9000000,
                  5000000,
                  5000000,
                  7000000),
  tot_pop_max = c(13000000,
                  9000000,
                  12000000,
                  2000000,
                  6000000,
                  3000000,
                  10000000,
                  6000000,
                  6000000,
                  8000000))
```

It is easy to have estimates of the rural population of each macroregion by subtracting the urban population from the estimates of the urban population.

```{r total, rural urban and rural population of the macroregions}
# total and urban population 
macroregion_pop_165AD_rural_urban_df <- left_join(
  macroregion_pop_165AD_df,
  macroregions_urban_population_df)

# rural population
macroregion_pop_165AD_rural_urban_df$rural_pop_min <- macroregion_pop_165AD_rural_urban_df$tot_pop_min - macroregion_pop_165AD_rural_urban_df$urban_pop
macroregion_pop_165AD_rural_urban_df$rural_pop_max <- 
macroregion_pop_165AD_rural_urban_df$tot_pop_max - macroregion_pop_165AD_rural_urban_df$urban_pop
```

To estimate the rural population in each province, we distribute the rural population living in each macroregion amongst the provinces that form it, proportionately to their area.
```{r urban, rural and total population by province}
# add the province's urban population to the full info df
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_full_info_df,
  province_urban_population_df
)

# add the populations of the macroregion
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_full_info_df,
  # add prefix macroregion to the column names to avoid confusion
  macroregion_pop_165AD_rural_urban_df %>% 
    setNames(c("macroregion",
               paste0(
                 "macroregion_",
                 colnames(macroregion_pop_165AD_rural_urban_df)[-1])))
)

# add the rural population proportionately to the area of the province
provinces_macroregions_full_info_df$rural_pop_max <- 
  provinces_macroregions_full_info_df$macroregion_rural_pop_max*provinces_macroregions_full_info_df$area_proportion
provinces_macroregions_full_info_df$rural_pop_min <- 
  provinces_macroregions_full_info_df$macroregion_rural_pop_min*provinces_macroregions_full_info_df$area_proportion

# compute the min/max total population for each province
provinces_macroregions_full_info_df$tot_pop_min <- provinces_macroregions_full_info_df$urban_pop+
  provinces_macroregions_full_info_df$rural_pop_min
provinces_macroregions_full_info_df$tot_pop_max <- provinces_macroregions_full_info_df$urban_pop+
  provinces_macroregions_full_info_df$rural_pop_max
```

Check that total values of the estimates make sense
```{r check total population in macroregion}
# compare these two data frames with the population in macroregion_pop_165AD_df
provinces_macroregions_full_info_df %>% group_by(macroregion) %>%
  summarize(pop = sum(tot_pop_min))
provinces_macroregions_full_info_df %>% group_by(macroregion) %>%
  summarize(pop = sum(tot_pop_max))
```

Extract only population info per each province
```{r select population columns from full info df}
provinces_population_df <-
  provinces_macroregions_full_info_df[,c("province",
    "urban_pop",
    "rural_pop_min",
    "rural_pop_max",
    "tot_pop_min",
    "tot_pop_max")]
```

Finally save these results.
```{r save population by province as csv}
write.csv(provinces_macroregions_full_info_df,
          "../../results/economic_complexity/provinces_macroregions_full_info.csv")
write.csv(provinces_population_df,
          "../../results/economic_complexity/provinces_population.csv")

```

##### Countries
We perform a similar operation to estimate the urban and rural population who lived within the borders of modern day countries. 
We estimate the urban population using Hanson's dataset. 
We estimate the rural population by distributing the above estimates of rural populations proportionately to the percentage of area of a province falling in each country.
E.g. The province "Sicilia" falls 100% within the modern country of Italy, hence we assign all of Sicilia's rural population to Italy.
Instead if another province falls 50% in in a country and 50% in another country, we assign half of the province's rural population to the each country. (NEED TO FIND A CONCRETE EXAMPLE)

```{r country and provinces sf}
# find intersections between the two shapefiles of modern day countries and provinces
countries_provinces <- st_intersection(world_sf,provinces) %>%
  dplyr::select(c("iso3","area","province","geometry")) %>% # select only needed columns
  setNames(c("country","country_area","province","geometry"))
```

Compute the area of the intersections
```{r country and provinces areas}
# calculate the area of each intersection
countries_provinces$intersection_area <- st_area(countries_provinces)

# associate area of each province
countries_provinces <- left_join(countries_provinces,
                                 provinces_areas_df)
```

note that due to small differences between the shapefiles of the countries and the provinces, the sum of the areas of the intersections falling within a given province is not exactly equal to that of the province itself.
```{r corrective factors for areas}
check_areas_countries_provinces_intersection <- countries_provinces %>% 
  group_by(province) %>%
  summarize(sum_intersection_area = sum (intersection_area)) %>% 
  left_join(provinces_areas_df)
check_areas_countries_provinces_intersection$area_correction_factor <- check_areas_countries_provinces_intersection$sum_intersection_area/check_areas_countries_provinces_intersection$area
```

From now on, we use this total intersection area as our province area to avoid complications.

Compute how much of each province's total area fell in each intersection.



To estimate the rural and urban population for each country, we consider the intersection between the countries and the ancient provinces. Then we 

ZIPPO

### Occupation TO DO
Add farmers (proportionally to total population. Why?)

### Language TO DO
Assume the same distribution of professions in the (not analysed) Greek inscriptions and use their locations to proportionally increase numbers in the provinces. 
NEED GREEK DATA

## Specialisation function for updates TO DO NOT PRIORITY
We create a function to subdivide an occupation into suboccupations as new evidence is gathered

## Apply bias correction (in different orders)

FILES TO USE: country_table, province_table, cities_table_list
